autoscale: true
# Чатбот-синоптик
## **Разработка и загрузка в облако**

---

![right](laptop.jpeg)
# [fit] Чекинилка (и там доп. материалы)

```
macspython.pw
```

**Логин:** Имя Фамилия (по-русски)
**Пароль:** 12345

---
# [fit] Чем закончилось последнее занятие 

- Мы написали простого бота
- Научили его отвечать на сообщения
- Научились пользоваться API прогноза погоды


---
[.build-lists: true]
# [fit] Сегодня мы закончим чатбота

- Научимся показывать в чатботе кнопки
- Научим запоминать город пользователя
- Создадим базу данных
- Запустим свой сервер для просмотра базы данных
- Загрузим чатбота + базу в облако **Amazon**


---
# 1. Поехали! 

Воспроизведем то, на чем закончили раньше.

- Установим **requests, telepot**
- Возьмем пример кода с **github** (доп.материалы)
- Запустим, пообщаемся с ботом

---
![right](coffee.jpeg)
# ✅ Задание 


Сейчас бот на все сообщения отвечает: *"Ты сказал XXX"* .

Научите бота отвечать что-то еще вместо этого.



---
# 2. Кнопки 

Научим бота показывать кнопки. Они передаются в виде списка списков:



[.code-highlight: 4-7]


```python
bot.sendMessage(
    chat_id=chat_id,
    text=reply,
    reply_markup=ReplyKeyboardMarkup(
        keyboard=[['Кнопка!']],
        resize_keyboard=True
    )
)


```

---
![right](coffee.jpeg)
# ✅ Задание 


Наш бот должен показывать две кнопки: **“Установить город”** и **“Узнать погоду”**. 

Добавьте в бота эти кнопки.


---
# 3. Кнопки в отдельной функции


## Зачем?

Потому что эта функция будет расти, а смотреть на одну длинную программу - тяжеловато. Нужно дробить на функции.


```python
def process_chat_message(msg):
    text = msg['text']
    print(text)
    reply = 'Ты сказал ' + text
    buttons = [['Установить город', 'Узнать погоду']]
    return reply, buttons
```

---
![right](coffee.jpeg)
# ✅ Задание 


Бот показывает кнопки в один ряд. 

*Сделайте так, чтобы одна кнопка была под другой.*



---
# 4. Функция в отдельном файле


Создадим файл, перенесем туда функцию - и импортируем в файл с логикой бота.

```python
from process_message import process_chat_message
```

---
![right](coffee.jpeg)
# ✅ Задание 

- Откройте файл, который мы создали. 
- Найдите строчку, которая отвечает за вывод текста в консоли.
- Добавьте туда принт **chat_id** и **юзернейма** автора сообщения.




---
# [fit] 5. Распознаем нажатия разных кнопок


- Как сделать так, чтобы бот понимал, что человек нажимает кнопку, а не вводит текст вручную?
- Научим бота отвечать по-разному в зависимости от нажатия кнопок.


---
# [fit] 5. Распознаем нажатия разных кнопок

```python

def process_chat_message(msg):
    text = msg['text']

    if text == 'Установить город':
        reply = 'Хорошо, устанавливаю город'

    elif text == 'Узнать погоду':
        reply = 'Узнаю погоду'

    else:
        reply = 'Ты сказал ' + text
```


---
![right](coffee.jpeg)
# ✅ Задание 

Измените текст в случае свободного ввода на какой-нибудь другой. 
Например, *“Я не понимаю тебя, человек. Используй кнопки”*.




---
#  6. Учимся запрашивать город


- Нажмите **“Установить город”**. Введите какой-нибудь город. Что ответит бот? 
- Как научить бота отвечать **“Сохраняю город XYZ”**?

---
![right](coffee.jpeg)
# ✅ Задание 

- Пусть несколько человек напишут одному боту. 
- Один человек должен написать **“Установить город”**, потом второй должен ввести **“Москва”**.
- Что произошло? Почему так? Как это исправить?


---
# [fit] 7. Чиним логику ожидания ответа



Исправим предыдущую проблему: флаг `waiting` будет свой у каждого пользователя.


---
![right](coffee.jpeg)
# ✅ Задание 

- Мы сделали свой флаг `waiting` у каждого пользователя.
- А как сделать так, чтобы бот запоминал города каждого пользователя?




---
# [fit] 8. Добавим сохранение городов в словаре


При сохранении города бот должен сохранять его в словаре `cities`. При запросе погоды - бот должен доставать его из словаря `cities`.

```python
# ###
cities = {}
# ... при установке города
cities[username] = city
# ... при получении города
city = cities[username]

```

---
![right](coffee.jpeg)
# ✅ Задание 

- Установите город. Убедитесь, что он сохранился.
- Добавьте перед каждым ответом пользователю вывод на печать словаря с городами. Посмотрите, как он накапливается.


---
# 9. Запрос погоды 

Вместо фразы "Узнаю погоду в городе N" добавим настоящий запрос к сервису прогноза погоды.

- Это будет отдельный файл `weather.py` с функцией `get_weather`.
- Файл `process_message.py` должен будет импортировать в себя эту функцию.
- Какой аргумент должна принимать функция `get_weather` ? 


---
![right](coffee.jpeg)
# ✅ Задание 

Файл `weather.py` работает не только вместе с чатботом, 
его можно запустить самостоятельно. 

- Запустите его. Какой город он проверяет по умолчанию?
- Замените город на какой-нибудь другой.
- Что будет, если передать несуществующий город? Как это починить?  

---

# [fit] 10. Исправим ошибку несуществующего города

Если в ответе от погодного сервиса нет города - мы должны сказать пользователю “Город не найден”.


```python
# ###
data = response.json()

pprint(data)

if 'main' not in data:
    response = 'Город ' + city + ' не найден. Вы нигде не опечатались?'
else:
    # ... все хорошо, достаем погоду

```

---
![right](coffee.jpeg)
# ✅ Задание 

Запустите чатбота. Убедитесь, что несуществующие города не ломают его.

---
![right](coffee.jpeg)
# ✅ Задание 

Остановите бота и запустите заново - запросите погоду без установки города. 
Что произошло? Почему так?

---

[.build-lists: true]
#  11. Добавим базу данных!

- База данных - это таблица со значениями. Какие строки должны быть у нас в таблице?
- Для работы базы данных потребуется несколько новых библиотек:
  - `flask`
  - `flask-admin`
  - `flask-sqlalchemy`
- Установите библиотеки. 
- Скопируйте и запустите необходимые файлы.

---
![right](coffee.jpeg)
# ✅ Задание 

- Добавьте и удалите несколько городов. 
- Остановите сервер с базой данных и запустите снова. Города потеряются?


---
# [fit] 12. Подключим чатбота к базе данных

У нас есть отдельно чатбот, и отдельно база данных. Они не знают друг о друге. 
Нужно подключить чатбота к базе.

- Скопируйте обновленный файл `process_message.py` к себе. Запустите чатбота.
- Сохраните город через чатбота, убедитесь, что он появился в БД.

---
![right](coffee.jpeg)
# ✅ Задание 

Почему город сохраняется в БД, но погоду все равно узнать невозможно? 


---
# [fit] 13. Добавим проверку наличия города в БД

- Мы должны ходить в БД не только при сохранении города, но и когда пользователь говорит “Узнать погоду”.

- Мы должны проверить, есть ли в БД строчка, соответствующая этому юзеру.


---
![right](coffee.jpeg)
# ✅ Задание 

Проверьте все сценарии:

- Города можно сохранять
- Города можно изменять
- Изменения отражаются в БД
- Запрос погоды работает.


---
# [fit] 14. Вынесем логику сохранения в функции

Нам нужно сделать 5 функций:

- **`set_waiting()`**: включить ожидание ввода города
- **`clear_waiting()`**: снять ожидание ввода
- **`is_waiting()`**: проверить: ждать ли ввода?
- **`save_city()`**: записать в БД город
- **`get_city()`**: получить из БД  город

---
![right](coffee.jpeg)
# ✅ Задание 

- Сравните код до и после ввода функций.
- Что легче читается?

---
# 15. Загрузка в облако!

- Скачайте еще две библиотеки для работы с Amazon: `aws-cli, zappa`
- Настройте компьютер: `aws configure`. Подробности на **github**
- Скачайте адаптированную версию чатбота
- Загрузите в облако: `zappa init`, потом `zappa deploy dev`
- После загрузки вы получите адрес чатбота в облаке. Его нужно будет отправить на сервер Telegram (см. **github**)

---
![right](coffee.jpeg)
# ✅ Задание 

- Остановите все программы на компьютере. Проверьте чатбота.
- Если он отвечает - у вас теперь есть рабочий чатбот в облаке :)
